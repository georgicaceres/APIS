
# SLASH COMMAND  - SLACK API
## Qué es un slash command?
Es un mensaje que comienza con un slash (`/`) e invoca un comando que ejecuta determinadas acciones a diferencia de los mensajes regulares. Por ejemplo, `/topic new_topic` es un comando que cambia el tópico del canal en el que se invoca a "new_topic".

Existen al menos tres tipos de slash commands que funcionan de manera similar pero son útiles para distintas situaciones.
- **Built-in Commands**. Construidos sobre Slack y disponibles para todos los espacios de trabajo.  [Aquí hay una lista](https://slack.zendesk.com/hc/en-us/articles/201259356-using-slash-commands?sid=zd-uf-t638a9wsy-u930hk5cj)  completa con descripciones acerca de lo que hace cada uno.
- **Slack App Commands**. Escritos por desarrolladores, usualmente disparan una acción (como postear un gif, agregar tareas a un To do list , etc). Pueden ser instalados en tu espacio de trabajo o también distribuido a otros.
- **Custom commands**. Antigua manera, no recomendada.

## Construyendo nuestro slash command
 La API de Slack nos provee información suficientemente clara para nuestro propósito acá: [Slack API](https://api.slack.com/). De todas maneras, enumeraremos y explicaremos brevemente los pasos a seguir:
- Comenzar creando una Slack App clickeando en el botón **Start Building** en la homepage. Se requiere un nombre para nuestra app y un espacio de trabajo sobre el cual se va a desarrollar la misma.
- En **Features**, dirigirse a Slash Commands y clickear **Create new command**. Completar los campos obligatorios (el comando de invocación, la url a la que se le hace la request y una descripción de lo que hace). Listo!
- **OPCIONAL PERO MUY ÚTIL:** Para que sea posible testear en nuestro espacio de trabajo si el comando está funcionando aún  sin haberlo publicado en internet, nos valemos de la ayuda de [ngrok](https://ngrok.com/). Las instrucciones para instalar y ponerlo a punto están debidamente detalladas en la web. Es simple!
- Por último, nos resta escribir nuestro código en el lenguaje que más nos guste, en este caso JS con node express.

## Algunas consideraciones

- Cuando invocamos un slash command el mensaje (y la data del mismo) son enviados a la URL que seteamos vía `POST`.
- `req.body.text` recupera el mensaje ingresado por el usuario después de la invocación.
- Existen varias formas de responder el request: un JSON con texto plano ([Basic Formatting](https://api.slack.com/docs/messages/builder?msg=%7B%22text%22%3A%22This%20is%20a%20line%20of%20text.%5CnAnd%20this%20is%20another%20one.%22%7D)) o customizando la apariencia ([Attachments](https://api.slack.com/docs/messages/builder?msg=%7B%22attachments%22%3A%5B%7B%22fallback%22%3A%22Required%20plain-text%20summary%20of%20the%20attachment.%22%2C%22color%22%3A%22%2336a64f%22%2C%22pretext%22%3A%22Optional%20text%20that%20appears%20above%20the%20attachment%20block%22%2C%22author_name%22%3A%22Bobby%20Tables%22%2C%22author_link%22%3A%22http%3A%2F%2Fflickr.com%2Fbobby%2F%22%2C%22author_icon%22%3A%22http%3A%2F%2Fflickr.com%2Ficons%2Fbobby.jpg%22%2C%22title%22%3A%22Slack%20API%20Documentation%22%2C%22title_link%22%3A%22https%3A%2F%2Fapi.slack.com%2F%22%2C%22text%22%3A%22Optional%20text%20that%20appears%20within%20the%20attachment%22%2C%22fields%22%3A%5B%7B%22title%22%3A%22Priority%22%2C%22value%22%3A%22High%22%2C%22short%22%3Afalse%7D%5D%2C%22image_url%22%3A%22http%3A%2F%2Fmy-website.com%2Fpath%2Fto%2Fimage.jpg%22%2C%22thumb_url%22%3A%22http%3A%2F%2Fexample.com%2Fpath%2Fto%2Fthumb.png%22%2C%22footer%22%3A%22Slack%20API%22%2C%22footer_icon%22%3A%22https%3A%2F%2Fplatform.slack-edge.com%2Fimg%2Fdefault_application_icon.png%22%2C%22ts%22%3A123456789%7D%5D%7D)). También se pueden agregar botones que disparen otras acciones ([Message Buttons](https://api.slack.com/docs/messages/builder?msg=%7B%22text%22%3A%22Would%20you%20like%20to%20play%20a%20game%3F%22%2C%22attachments%22%3A%5B%7B%22text%22%3A%22Choose%20a%20game%20to%20play%22%2C%22fallback%22%3A%22You%20are%20unable%20to%20choose%20a%20game%22%2C%22callback_id%22%3A%22wopr_game%22%2C%22color%22%3A%22%233AA3E3%22%2C%22attachment_type%22%3A%22default%22%2C%22actions%22%3A%5B%7B%22name%22%3A%22game%22%2C%22text%22%3A%22Chess%22%2C%22type%22%3A%22button%22%2C%22value%22%3A%22chess%22%7D%2C%7B%22name%22%3A%22game%22%2C%22text%22%3A%22Falken%27s%20Maze%22%2C%22type%22%3A%22button%22%2C%22value%22%3A%22maze%22%7D%2C%7B%22name%22%3A%22game%22%2C%22text%22%3A%22Thermonuclear%20War%22%2C%22style%22%3A%22danger%22%2C%22type%22%3A%22button%22%2C%22value%22%3A%22war%22%2C%22confirm%22%3A%7B%22title%22%3A%22Are%20you%20sure%3F%22%2C%22text%22%3A%22Wouldn%27t%20you%20prefer%20a%20good%20game%20of%20chess%3F%22%2C%22ok_text%22%3A%22Yes%22%2C%22dismiss_text%22%3A%22No%22%7D%7D%5D%7D%5D%7D)).
- Para agregar funcionabilidad a los botones, debemos ingresar a nuestra app en la web, en **Features** dirigirnos a Interactive Components y habilitar la opción. En el campo URL ingresaremos la ruta a la que llamaremos (por `POST`) cuando nuestro botón sea presionado. 
